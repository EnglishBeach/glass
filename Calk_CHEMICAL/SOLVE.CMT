#define RECOVERY 1

#include "chem.h"
#include "wserv.h"
#include <string.h>
#include <alloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <values.h>
#include <fcntl.h>
#include <math.h>
#include <keys.h>

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ This  module  contains all the routines that handle the process บ
ณ of solving CHEMICAL task.                                       บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/


enum { PRIMARY, CONSISTENCY, GENERAL };
enum { REVIEWAL, ACCURATE };
enum { L_CONT=1, L_GOBAK, L_NOACC, L_ALACC, L_DFACC, L_ABANDON };

static int errata[22][3];
static int total_errors;
static char mask[50];
static int I0,J0,F0,L0,mpnt,mpex=6,mint;
static Bool selected[50];
static Bool window_on_screen=false;


typedef struct {
	float g;
	unsigned char d;
} C2;

typedef struct {
	char adinf[12];
	char flag;
	C2   *c2;
} C1;

static float B[50],B1[50];
static double dnfv,**AL=NULL;
static C1    *C=NULL;
static float **A=NULL,*nx=NULL,*nmax=NULL,*z=NULL,*g=NULL;
static float *Tx=NULL,*Px=NULL;
static int   *ixJ=NULL,*ixN=NULL,M0,N0;
static int   M[17];
static char  *headln,*lowpane_addr[6];

/*ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ*/

static void build_solution_window (void)

{
	char *p;
	int i;
	int heigth=min(N0,19)+5;

	wblock (10,1,61,heigth,49,NULL,1);
	wattr (49);
	p=wgeta(31,1);            wputs(&p,"ัออออออออออออัออออออออออออั");
	p=wgeta(31,heigth); wputs(&p,"ฯออออออออออออฯออออออออออออฯ");
	for (i=2;i<heigth;i++) {
		p=wgeta(31,i);         wputs(&p,"ณ            ณ            ณ"); }
	p=wgeta(10,4);
	wputs(&p,"วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤถ");
	p=wgeta(12,2); wputs(&p,"ฅฌฏฅเโใเ,K");
	p=wgeta(12,3); wputs(&p,"ขซฅญจฅ, โ");
}

static void view_tp (int pnt)

{
	int i,x;
	char *p,buffer[40];

	for (i=0;i<3&&pnt<M0;i++,pnt++) {
		x=33+13*i;
		sprintf(buffer,"%10.4g",Tx[pnt]); p=wgeta(x,2); wputs(&p,buffer);
		sprintf(buffer,"%10.4g",Px[pnt]); p=wgeta(x,3); wputs(&p,buffer); }
}

static void view_row (int i, int y, int j, Bool comp, int ph)

{
	int k;
	char *p, buffer[50];

	y+=5;
	if (comp) {
		buffer[0]=' ';
		print_form_matr (mask,A[i],J0,C[i].adinf,ph,buffer+1);
		strcat(buffer,"                    ");
		buffer[20]=0;
		p=wgeta(11,y); wputs (&p,buffer); p+=4; }
	else
		p=wgeta(33,y);

	for (k=0;k<3&&j<M0;k++,j++) {
		sprintf (buffer,"%#10.5e",C[i].c2[j].g);
		wputs(&p,buffer); p+=6; }
}

static void view_table (int io, int jo, Bool comp, Bool tp)

{
	int i,y,ph;

	for (ph=0;ixN[io]>M[ph];ph++);
	if (tp)
		view_tp(jo);
	for (y=0,i=io;i<N0&&y<19;i++,y++) {
		view_row (ixN[i],y,jo,comp,ph);
		while(ixN[i]>M[ph]) ph++; }
}

static void view_results (void)

{
	int beg_point=0, beg_line=0;
	int top_of_bottom;

	build_solution_window();
	view_table (0,0,true,true);
	wgetkey();
	wrestore();
}


static void print_results (void)
{}

static void grafix_shop (void)
{}

void output_results (void)

{
	static char *choices[] = {
		"เฎcฌฎโเ",
		"ฅ็โ์",
		"เไจช","",
		"๋ๅฎค" };

	int disa[] = { 0,0,0,1,0 };
	int j=1,flg=MF_esc;

	for (;;) {
		j=wmenu (64,2,11,5,1,choices,disa,44,45,48,46,47,0,"ฅงใซ์โโ",
					flg,j,1,NULL,NULL);

		flg|=MF_blk;
		switch (j) {
			case 1: view_results (); break;
			case 2: print_results (); break;
			case 3: grafix_shop (); break;
			case 5:
				if (wverify(61,8,"๋ๅฎค",99)>0) {
					wrestore();
					return; } } }
}


/*ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ*/


/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Convert conventional float to native one                        บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static float cvfloat (int cvf)

{
	return ((cvf>>7)+(float)(cvf&0x7F)/100.0);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Conditionally remove a window.                                  บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void cwremove (void)

{
	if (window_on_screen) {
		wrestore();
		window_on_screen=false; }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Free  all  core  space  allocated to dynamic arrays. Note, that บ
ณ cvfree is used rather than C library free function to  do  this บ
ณ work.                                                           บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void free_work (void)

{
	int i;

	for (i=0;i<I0;i++) {
		cvfree (A[i]);
		cvfree (C[i].c2); }
	cvfree (A);
	cvfree (C);
	cvfree (nmax);
	cvfree (nx);
	cvfree (g);
	cvfree (z);
	for (i=0;i<J0+L0;i++) cvfree (AL[i]);
	cvfree (AL);
	cvfree (Tx);
	cvfree (Px);
	cvfree (ixJ);
	cvfree (ixN);

	cwremove();
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Store given three specificatoin of an error into errata.        บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void store_errata (int group, int subgroup, int index)

{
	if (total_errors<22) {
		errata[total_errors][0]=group;
		errata[total_errors][1]=subgroup;
		errata[total_errors++][2]=index; }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Display  all  accumulated  errors.  The <set> parameter affects บ
ณ only on window header.                                          บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool display_errata (int set)

{
	ice **sim[] = { &ctask.source, &ctask.exclud, NULL, &ctask.fixed };
	cornice *com[] = { &ctask.solut, NULL, &ctask.cstrain };
	char *header[] = { " ใกซจเใ๎โc๏ ข งคญจจ ",
							 " ฅ ฎกเงใ๎โc๏ จง งคญญ๋ๅ โฎฌฎข ",
							 " โcใโcโขใ๎โ ข เc็ฅโฅ " };
	char *errtext[] = {
		"cชซ๎็ฅฌ๋ฉ ชฎฌฏฎญฅญโ",
		"ฎฌฏฎญฅญโ เcโขฎเ #",
		"จชcจเใฅฌ๋ฉ ชฎฌฏฎญฅญฅโ",
		"ฎฌฏฎญฅญโ ฎฃเญจ็ฅญจ๏ #",
		"ซฅฌฅญโ",
		"จชcๆจ๏ ฏฅเฅชเ๋ขฅโ ญซจ็จฅ โฎฌ",
		" เc็ฅโ ญฅ ขชซ๎็ฅญ๋ จฎญญ๋ฅ ไฎเฌ๋" };

	int i,gr,sg,ix;
	ice *v;
	char *p,*q,*r,buffer[40];
	char elm[6] = {0}, adinf[10] = "";
	int stoi[6] = { 128 };

	if (total_errors!=0) {
		wblock(35,2,43,total_errors+2,8,header[set],1);
		wattr(9);
		q=wgeta(37,3);
		for (i=0;i<total_errors;i++) {
			gr=errata[i][0];
			sg=errata[i][1];
			ix=errata[i][2];
			p=q;
			wputs(&p,errtext[gr-1]);
			switch(gr=errata[i][0]) {
			case 1:
			case 3:
				v=*sim[gr]+ix;
				r=buffer;
				*r++=' ';
				print_form(v->el,v->stoi,v->adinf,v->flag,r,false,40);
				break;
			case 2:
			case 4:
				itoa(sg+1,buffer,10);
				r=buffer+strlen(buffer);
				v=com[gr-2]->p[sg]+ix;
				*r++=' ';
				print_form(v->el,v->stoi,v->adinf,v->flag,r,false,40);
				break;
			case 5:
			case 6:
				p+=2;
				elm[0]=ix;
				print_form (elm,stoi,adinf,0,buffer,false,40);
				break;
			case 7:
				*buffer=0;
				break; }
			wputs(&p,buffer);
			wputs(&p,".");
			q+=160; }
		return (false); }
	else
		return (true);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Correct  all correctable (i.e., errors found in source task but บ
ณ not ones telling that, for example, there's no  some  athom  in บ
ณ database)  errors in source task by delete components that have บ
ณ caused an error.                                                บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool correct_errors (int set)

{
	int i;
	Bool check_ok;

	cwremove();
	check_ok=display_errata(set);
	if (!check_ok&&(wverify (3,3,"ฎเเฅชโจเฎขโ์ งคญจฅ",99))>0) {
		wrestore();
		enable_viewing (false);
		for (i=0;i<total_errors;i++)
			switch (errata[i][0]) {
			case 2:
			case 4:
				delete_member(errata[i][1],errata[i][2],errata[i][0]-2);
				break;
			case 1:
			case 3:
				delete_icicle(errata[i][1],errata[i][0]);
				break; }
		enable_viewing (true);
		view_screen (); }
	else
		wrestore();
	return (check_ok);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Build <mask> array, each entry of that to contain element as it บ
ณ appears  in  "Source  mix"  part  of task, in descending order. บ
ณ Total number of entries filled will be stored into J0.          บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool build_mask (void)

{
	int i,j,k;
	float b;
	char w;

	J0=0;
	for (i=0;i<ctask.total[0];i++)
		for (j=0;j<6&&(ctask.source+i)->el[j]!=0;j++) {
			for (k=0;k<J0;k++)
				if ((ctask.source+i)->el[j]==mask[k]) break;
			if (k==J0) {
				mask[J0]=(ctask.source+i)->el[j];
				B[J0]=0;
				if (J0++==48-ctask.total[4]) {
					tell_error (
						" งค็ฅ กฎซ์่ฅ, ็ฅฌ 48 ํซฅฌฅญโฎข ญ ซจญฅฉญ๋ๅ cข๏งฅฉ",99);
					return (false); } }
			B[k]+=cvfloat((ctask.source+i)->stoi[j])*(ctask.source+i)->amo; }

	if (ctask.ion) {
		mask[J0]=255;
		B[J0++]=0.0; }
	mask[J0]=0;

	for (j=0,b=0;j<J0;j++) b+=B[j];
	for (j=0;j<J0;j++) B[j]/=b;

	for (j=0;j<J0;j++) {
		i=j;
		for (k=j+1;k<J0;k++)
			if (mask[k]<mask[i]) i=k;
		if (i!=j) {
			w=mask[j]; mask[j]=mask[i]; mask[i]=w;
			b=B[j]; B[j]=B[i]; B[i]=b; } }

	L0=ctask.total[4];
	return (true);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Fix up components by corrections B vector. The result is stored บ
ณ into array B1.                                                  บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void fix_up (void)

{
	int i,j,k;
	unsigned char elm;
	float max_abundance,x;
	ice *p;

	for (j=0;j<J0;j++)
		B1[j]=B[j];
	dnfv=0;
	for (i=0;i<ctask.total[3];i++) {
		p=ctask.fixed+i;
		max_abundance=MAXFLOAT;
		for (j=0;j<6&&(elm=p->el[j])!=0;j++) {
			for (k=0;k<J0;k++)
				if (mask[k]==elm) break;
			if (max_abundance>(x=B[k]/cvfloat(p->stoi[j])))
				max_abundance=x; }
		for (j=0;j<6&&(elm=p->el[j])!=0;j++) {
			for (k=0;k<J0;k++)
				if (mask[k]==elm) break;
			B1[k]-=max_abundance*cvfloat(p->stoi[k])*p->amo/100.0; }
		if (!(p->flag&DB_sol)) dnfv+=max_abundance*p->amo/100.0; }

	for (j=0;j<J0-ctask.ion;j++)
		if (B1[j]<=0)
			store_errata(6,0,mask[j]);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns  a  value  of thermodynamical parameter in point number บ
ณ <i>, assuming <tp0> first point, <tp1>  -  last  point,  <n>  - บ
ณ total  number  of  points  in interval. The intersection method บ
ณ (linear  or  logarithmical)  is  depending   on   <ctask.nstep> บ
ณ variable.                                                       บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static double get_tp (float tp0, float tp1,int i,int n)

{
	if (n==0||tp1==0||i==0) return (tp0);
	if (ctask.logstep)
		return (tp0*pow(tp1/tp0,i/(n-1.0)));
	else
		return (tp0+(tp1-tp0)*i/(n-1.0));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns value of parameter in base point <point>.               บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static double get_tp_1 (float tp0, float tp1, int point)

{
	return (get_tp(tp0,tp1,point,ctask.nstep));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns  value  of parameter in enaccuratement point <point> of บ
ณ interval <intvl>.                                               บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static double get_tp_2 (float tp0,float tp1, int intvl, int point)

{
	return(get_tp(get_tp_1(tp0,tp1,intvl),get_tp_1(tp0,tp1,intvl+1),
						point+1,mpex+2));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Compute normalized Gibbs energy from fi and h read from base.   บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static double compute_g (float *f,float h,double t)

{
	t/=10000.;
	return(h/t*1000.0-f[0]-f[1]*log(t)-f[2]/t/t-f[3]/t-f[4]*t-
				f[5]*t*t-f[6]*t*t*t);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Start reading base.                                             บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool start_reading_base (void)

{
	return (base_open(O_RDONLY,0));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Close base file.                                                บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void end_reading_base (void)

{
	base_close ();
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns  true  if  compound  in  base entry <entry> is found in บ
ณ given ice pointed by p.                                         บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool find_in_ice (db_entry *entry, ice *p, int n)

{
	int i;

	for (i=0;i<n;i++) {
		if (memcmp(entry->el,p[i].el,6)==0&&
			memcmp(entry->stoi,p[i].stoi,12)==0&&
			strcmp(entry->adinf,p[i].adinf)==0&&
			(entry->flag&DB_sol)==(p[i].flag&DB_sol)) return (true); }
	return (false);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Read  next  base  entry  that  matches to a source mix. Returns บ
ณ false, if no one is found.                                      บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool read_base_entry (db_entry *entry)

{
	Bool more=true;

	do {
		while (!base_search(entry,false,mask,&more))
			if (!more) return (false); }
	while (find_in_ice (entry,ctask.fixed,ctask.total[3])||
		find_in_ice (entry,ctask.exclud,ctask.total[1])!=ctask.incex);
	return (true);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Searches  stoichiometrical  mattrix for exact match to conpound บ
ณ given, returns line number in  mattrix  when  found;  otherwise บ
ณ returns -1.                                                     บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

int find_in_mattrix (char *el,int *stoi,char *adinf,char flag)

{
	int i,j,k,l,m,mt;

	for (mt=0;mt<6&&el[mt]!=0;mt++);

	for (i=0;i<I0;i++) {
		if (strcmp(adinf,C[i].adinf)!=0||(flag&DB_sol)!=(C[i].flag&DB_sol))
			continue;
		m=mt;
		l=mt;
		for (j=0;j<J0;j++)
			if (A[i][j]!=0) {
				l--;
				for (k=0;k<6&&el[k]!=0;k++)
					if (mask[j]==el[k]&&A[i][j]==cvfloat(stoi[k])) m--; }
		if (m==0&&l==0) return (i); }
	return (-1);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Adds  new  compound  to  the mattrix, intialises defect columns บ
ณ with <def_d> value.                                             บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

void add_row_to_mattrix (char *el,int *stoi,char *adinf,char flag,char def_d)

{
	int i,j,k;

	Realloc (A,I0+1);
	A[I0]=NULL;
	Realloc (C,I0+1);
	C[I0].c2=NULL;
	i=I0++;

	Alloc (A[i],J0+L0);
	Alloc (C[i].c2,mpnt);

	for (j=0;j<J0+L0;j++) A[i][j]=0.0;
	for (j=0;j<mpnt;j++)  C[i].c2[j].d=def_d;
	strcpy (C[i].adinf,adinf);
	C[i].flag=flag&DB_sol;

	for (k=0;k<6&&el[k]!=0;k++) {
		for (j=0;j<J0;j++)
			if (mask[j]==el[k]) break;
		A[i][j]=cvfloat(stoi[k]); }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Expand  mattrix  upto  total  (including  enaccurate) number of บ
ณ points in solving.                                              บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void expand_mattrix (void)

{
	int i,j;

	for (i=0;i<I0;i++) {
		Realloc (C[i].c2,mpnt+mint*mpex);
		display_core();
		for (j=mpnt;j<mpnt+mint*mpex;j++)
			C[i].c2[j].d=255; }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Computes  defect between given temperature t and range t0...t1. บ
ณ Defect is a interval between t and  nearer  end  of  the  range บ
ณ t0...t1  (i.e.,  t0-t if t<t0 and t-t1 otherwise), expressed in บ
ณ units of 20K. If t is within the range, defect is assumed to be บ
ณ zero.                                                           บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static char defect (float t0, float t1, float t)

{
	float dt;

	if (t0<t&&t<t1)
		return (0);
	else {
		dt=t<t0?t0-t:t-t1;
		return(dt>5000.0?251:dt/20.0+1); }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Performs  one 'Partitioning' pass from quick-sort cheme, moving บ
ณ all solid-phase compounds to top rows of stoi  mattrix  leaving บ
ณ all vapor-phase compounds in the bottom rows.                   บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void sort_mattrix (void)

{
	int l,r,j;
	float w;
	char c,tmp[12];
	C2 y;

	l=0; r=I0-1;
	do {
      while (C[l].flag&DB_sol&&l<=r) l++;
      while (!(C[r].flag&DB_sol)&&l<=r) r--;
      if (l<r) {
         for (j=0;j<J0+L0;j++) { w=A[l][j]; A[l][j]=A[r][j]; A[r][j]=w; }
         strcpy (tmp,C[l].adinf); strcpy (C[l].adinf,C[r].adinf);
         strcpy(C[r].adinf,tmp);
         c=C[l].flag; C[l].flag=C[r].flag; C[r].flag=c;
         for (j=0;j<mpnt;j++) {
				y=C[l].c2[j]; C[l].c2[j]=C[r].c2[j]; C[r].c2[j]=y; }
			l++; r--; } }
	while (l<r);
	M[0]=l;
	F0=1;
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Fills  in  columns  of  linear  constrains in stoi mattrix. The บ
ณ errors that  may  appear  (unability  to  find  a  compound  in บ
ณ mattrix, meaning that base is missing it) are stored in errata. บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void build_constrains_columns (void)

{
	int i,j,l;
	ice *v;

	for (l=L0-1;l>=0;l--) {
		B1[l+J0]=B[l+J0]=ctask.cstrain.right[l];
		for (j=ctask.cstrain.n[l]-1;j>=0;j--) {
			v=ctask.cstrain.p[l]+j;
			i=find_in_mattrix (v->el,v->stoi,v->adinf,v->flag);
			if (i<0)
				store_errata (4,l,j);
			else
				A[i][l+J0]=v->amo; } }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Appends  mattrix  and  builds  rows  for  solid  solutions. The บ
ณ compounds are copied as they are in the mattrix.                บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void build_solution_rows (void)

{
	int i,i1,j,k,l;
	ice *v;

	for (l=ctask.total[2]-1;l>=0;l--) {
		M[F0++]=I0;
		for (j=ctask.solut.n[l]-1;j>=0;j--) {
			v=ctask.solut.p[l]+j;
			i=find_in_mattrix (v->el,v->stoi,v->adinf,v->flag);
			if (i<0)
				store_errata (2,l,j);
			else {
				i1=I0;
				add_row_to_mattrix (v->el,v->stoi,v->adinf,v->flag,0);
				for (k=0;k<J0+L0;k++) A[i1][k]=A[i][k];
				for (k=0;k<mpnt;k++) C[i1].c2[k].g=C[i].c2[k].g;
				strcpy (C[i1].adinf,C[i].adinf); } } }
	M[F0]=I0;
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Allocates nmax array and working stirage for <kernel> routine.  บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void allocate_working_storage (void)

{
	int j;

	Alloc (nx,I0);
	Alloc (nmax,I0);
	Alloc (g,I0);
	Alloc (z,I0);
	Alloc (AL,J0+L0);
	for (j=0;j<J0+L0;j++) Alloc (AL[j],J0+L0);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Computes  maximal  concentrations  for  each  component in stoi บ
ณ mattrix. The max co is such one, when one or more of  elemental บ
ณ abundances becomes zero.                                        บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void compute_nmax ()

{
	int i,j;
	double t;

	for (i=0;i<I0;i++) {
		nmax[i]=MAXFLOAT;
		for (j=0;j<J0;j++)
			if (A[i][j]!=0&&nmax[i]>(t=B1[j]/A[i][j]))
				nmax[i]=t;
		if (nmax[i]>MAXFLOAT/10.0)
			nmax[i]=1e-5; }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Draw  window  telling  about  searching  in base with heigth of บ
ณ <heigth> and header <mess>.                                     บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void draw_searching_base_window (int heigth, char *mess)

{
	window_on_screen=true;
	wblock (16,8,40,heigth,42,mess,1);
	wattr (43);
	wfoot ("{Ctrl-Break} ญฅฌฅคซฅญญฎ ฏเฅชเ้ฅโ ฎฏฅเๆจ๎");
	wsetupbar (20,10,32,base_size());
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Build whole stoichiometrical mattrix                            บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool build_mattrix (void)

{
	db_entry entry;
	int i,j;
	double t;
	unsigned char dt;
	char *p,*p_com,buffer[20];

	if (!start_reading_base()) return (false);
	I0=0;
	mpnt=(ctask.nstep==0)?1:ctask.nstep;
	Alloc (A,1);
	Alloc (C,1);

	draw_searching_base_window (7," ๋กฎเช จง กง๋ ");
	p=wgeta(20,12); wputs(&p,"  ๋กเญฎ ชฎฌฏฎญฅญโฎข       0"); p_com=p-2;

	while (read_base_entry(&entry)) {
		if	((i=find_in_mattrix(entry.el,entry.stoi,entry.adinf,entry.flag))
					==-1) {
			i=I0;
			add_row_to_mattrix(entry.el,entry.stoi,entry.adinf,entry.flag,255);
			p=p_com; wputs(&p,itoa(I0,buffer,10)); display_core(); }
		for (j=0;j<mpnt;j++) {
			t=get_tp_1(ctask.t0,ctask.t1,j);
			dt=defect(entry.t[0],entry.t[1],t);
			if (dt<C[i].c2[j].d) {
				C[i].c2[j].d=dt;
				C[i].c2[j].g=compute_g(entry.f,entry.h,t); } } }
	end_reading_base();

	cwremove();

	total_errors=0;
	for (j=0;j<J0;j++) {
		for (i=0;i<I0;i++)
			if (A[i][j]!=0) break;
		if (i==I0)
			store_errata ((j==J0-1)?7:5,0,mask[j]); }

	build_constrains_columns();

	J0-=ctask.ion;
	L0+=ctask.ion;

	sort_mattrix ();
	build_solution_rows();
	allocate_working_storage();
	compute_nmax();
	display_core ();

	return (correct_errors(GENERAL));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Executes  second  pass  search  in base and fills in Ci mattrix บ
ณ columns for enaccurate points.                                  บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void fill_in_expanded_columns (void)

{
	db_entry entry;
	int i,j,k,l;
	double t;
	unsigned char dt;

	if (!start_reading_base()) Immediate_break;
	draw_searching_base_window (6," ฎข๋กฎเช cขฎฉcโข ");

	while (read_base_entry(&entry)) {
		i=find_in_mattrix(entry.el,entry.stoi,entry.adinf,entry.flag);
		for (j=0,l=mpnt;j<mpnt-1;j++)
			if (selected[j])
				for (k=0;k<mpex;k++,l++) {
					t=get_tp_2(ctask.t0,ctask.t1,j,k);
					dt=defect(entry.t[0],entry.t[1],t);
					if (dt<C[i].c2[l].d) {
						C[i].c2[l].d=dt;
						C[i].c2[l].g=compute_g(entry.f,entry.h,t); } } }
	end_reading_base();

	cwremove();
	return;
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Check   if   given   ice  pointed  by  <p>  contains  duplicate บ
ณ components.                                                     บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void check_dups (ice *p, int n, int group, int subgroup)

{
	int i,j;
	Bool marked[255] = { 0 };

	for (i=0;i<n;i++)
		for (j=n-1;j>i;j--)
			if (!marked[j]&&memcmp(p+i,p+j,sizeof(ice))==0) {
				marked[j]=true;
				store_errata (group,subgroup,j); }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Check  if  all  compounds  in given ice <p> may be consisted of บ
ณ source mix elements.                                            บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void consistency_check (ice *p, int n, int group, int subgroup)

{
	int i,j,k;
	Bool marked[255] = { 0 };

	for (i=n-1;i>=0;i--)
		if (!marked[i])
			for (j=0;j<6&&(p+i)->el[j]!=0;j++) {
				for (k=0;k<J0;k++)
					if (mask[k]==(p+i)->el[j]) break;
				if (k==J0) {
					marked[i]=true;
					store_errata (group,subgroup,i);
					break; } }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Builds  mask,  performs  all  the checks, then does a fixation. บ
ณ That is all the things precomes to building stoi mattrix.       บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool primary_build (void)

{
	int i;
	Bool check_ok;

	if (ctask.total[0]==0) {
		tell_error ("ฅ งคญ จcๅฎคญ๋ฉ cฎcโข",99);
		return (false); }
	total_errors=0;
	check_dups(ctask.exclud,ctask.total[1],1,0);
	for (i=0;i<ctask.total[2];i++)
		check_dups(ctask.solut.p[i],ctask.solut.n[i],2,i);
	for (i=0;i<ctask.total[4];i++)
		check_dups(ctask.cstrain.p[i],ctask.cstrain.n[i],2,i);

	if (!build_mask()) return (false);
	check_ok=correct_errors(PRIMARY);

	total_errors=0;
	consistency_check(ctask.exclud,ctask.total[1],1,0);
	consistency_check(ctask.fixed,ctask.total[3],3,0);
	for (i=0;i<ctask.total[2];i++)
		consistency_check(ctask.solut.p[i],ctask.solut.n[i],2,i);
	for (i=0;i<ctask.total[4];i++)
		consistency_check(ctask.cstrain.p[i],ctask.cstrain.n[i],4,i);

	fix_up ();
	return (correct_errors(CONSISTENCY)&&check_ok);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Solve system for given point.                                   บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static double solve_point (int m, double P,char *p_itr, char *p_err)

{
	int i;
	double l[50],s;

	for (i=0;i<I0;i++) g[i]=C[i].c2[m].g;
	s=kernel (P,A,B1,g,nx,nmax,z,AL,l,dnfv,I0,J0,L0,F0,M,p_itr,p_err);
	for (i=0;i<I0;i++)
		C[i].c2[m].g=nx[i]>options.sigfcy?nx[i]:0.0;
	return (s);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Solve system in all the points.                                 บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void solve_system (int pass)

{
	double P;
	int i,j,l;
	char *p,*p_pnt,*p_itr,*p_err,buffer[20];

	window_on_screen=true;
	wblock (16,8,40,10,42,(pass==REVIEWAL)?" ฅ่ฅญจฅ ":" โฎ็ญฅญจฅ ",1);
	wattr (43);
	wfoot ("{Ctrl-Break} ญฅฌฅคซฅญญฎ ฏเฅชเ้ฅโ ฎฏฅเๆจ๎");
	p=wgeta(22,12); wputs(&p,"ฎ็ช เc็ฅโ  1"); p_pnt=p-2;
	p=wgeta(40,12); wputs(&p,"จง ");
		wputs(&p,itoa(mpnt+((pass==ACCURATE)?mpex*mint:0),buffer,10));
	p=wgeta(22,14); wputs(&p,"โฅเๆจ๏       "); p_itr=p;
	p=wgeta(22,15); wputs(&p,"่จกช         "); p_err=p;

	switch (pass) {
	case REVIEWAL:
		wsetupbar (20,10,32,mpnt);
		for (i=0;i<mpnt;i++) {
			P=get_tp_1(ctask.p0,ctask.p1,i);
			p=p_pnt; wputs(&p,itoa(i+1,buffer,10));
			wappendbar(i+1);
			solve_point(i,P,p_itr,p_err); }
		break;
	case ACCURATE:
		if (mint==0) break;
		wsetupbar (20,10,32,mpex*mint+mpnt);
		for (i=0,l=mpnt;i<mpnt-1;i++)
			if (selected[i])
				for (j=0;j<mpex;j++,l++) {
					P=get_tp_2(ctask.p0,ctask.p1,i,j);
					p=p_pnt; wputs(&p,itoa(l+1,buffer,10));
					wappendbar(l+1);
					solve_point(l,P,p_itr,p_err); }
		break; }
	cwremove();
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns  true  if  i'th  compound  in  j'th interval appears or บ
ณ disappears.                                                     บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool check_row (int i,int j)

{
	float n1,n2;

	n1=C[i].c2[j].g;
	n2=C[i].c2[j+1].g;
	return ((n1+n2==0)!=(n1*n2==0));
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Returns  true  if  any  compoient  in  j'th interval appears or บ
ณ disappears.                                                     บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool check_range (int j)

{
	Bool Ok=false;
	int i,k;

	for (i=0;i<M[0];i++)
		Ok|=check_row (i,j);
	for (k=1;k<F0;k++)
		for (i=M[k];i<M[k+1];i++)
			Ok|=check_row (i,j);
	return (Ok);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ This  is an "exit procedure" called from wmenu. It dispalys all บ
ณ the compounds that changes status in  k'th  interval  in  lower บ
ณ pane of "Enaccurate intervals" window.                          บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void display_events (int k)

{
	char *p,buffer[50];
	char spaces_20[21] = "                   ";
	int i,j,f;

	p=wgeta(3,17); wputs (&p,"ร");
	p=wgeta(65,17); wputs (&p,"ด");
	p=wgeta(5,4); wputs (&p,headln);
	p=wgeta(52,4); wputs (&p," ๋กเญฎ "); wputs (&p,itoa(mint,buffer,10));
		wputs (&p," ฤ");

	j=0;
	for (i=0;i<M[0]&&j<6;i++)
		if (check_row(i,k)) {
			print_form_matr (mask,A[i],J0,C[i].adinf,0,buffer);
			strcat(buffer,(C[i].c2[k].g==0.0)?" \x1E":" \x1F");
			strcat(buffer,spaces_20);
			buffer[20]=0;
			p=lowpane_addr[j++]; wputs(&p,buffer); }
	for (f=1;f<F0;f++)
		for (i=M[f];i<M[f+1]&&j<6;i++)
			if (check_row(i,k)) {
				print_form_matr (mask,A[i],J0,C[i].adinf,f,buffer);
				strcat(buffer,(C[i].c2[k].g==0.0)?" \x1E":" \x1F");
				strcat(buffer,spaces_20);
				buffer[20]=0;
				p=lowpane_addr[j++]; wputs(&p,buffer); }
	for (;j<6;j++) {
		p=lowpane_addr[j];
		wputs(&p,spaces_20); }
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Generate  window header and array of six positions in low pane. บ
ณ They are used by the above routine.                             บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/


static void prepare_panes_video (char *p)

{
	float f;
	int i,j,k;

	if (ctask.t1==0) {
		strcpy (p," T=");
		f=ctask.t0; }
	else {
		strcpy (p," P=");
		f=ctask.p0; }
	p+=strlen(p);
	general_5_float (f,p);
	strcat (p," ");

	for (k=0,i=18;i<20;i++)
		for (j=5;j<60;j+=19)
			lowpane_addr[k++]=wgeta(j,i);

}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Converts given range to external ASCII.                         บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static void range_to_ascii (int i,char *p)

{
	double f0,f1;
	char buffer [20];

	if (ctask.t1==0) {
		f0=ctask.p0;
		f1=ctask.p1; }
	else {
		f0=ctask.t0;
		f1=ctask.t1; }

	memset (p,' ',14);
	p[14]=0;
	p+=2;
	general_5_float (get_tp_1(f0,f1,i),buffer);
	strcpy (p,buffer);
	strcat (p,",");
	general_5_float (get_tp_1(f0,f1,i+1),buffer);
	strcat (p,buffer);
	*(p+strlen(p))=' ';
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Local menu for "Enaccurate intervals" window.                   บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static int local_menu (void)

{
	static char *choices[] = {
		"เฎคฎซฆจโ์   (F9)",
		"งค",
		"ฅ ใโฎ็ญ๏โ์",
		"โฎ็ญ๏โ์ ขcฅ",
		"ฅเญใโ์ ใฌฎซ็ญจฅ",
		"เฅเขโ์ เฅ่ฅญจฅ" };

	int j=1;

	j=wmenu (58,6,17,6,1,choices,NULL,18,19,20,21,0,0,NULL,0,j,26,NULL,NULL);
	if (j>0)
		wrestore();
	else
		j=L_GOBAK;
	return (j);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Driver for "Enaccurate intervals" window.                       บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool search_enaccuratement (void)

{
	char heap[720],*list[48],headline[20];
	int disa[48],flg=MF_res|MF_fn,i,j;
	Bool cont;

	mint=0;
	if (mpnt==1) return (true);
	headln=headline;

	for (i=0;i<48;i++) {
		list[i]=heap+i*15;
		disa[i]=1; }

	prepare_panes_video(headline);
	for (i=0;i<mpnt-1;i++) {
		range_to_ascii(i,list[i]);
		selected[i]=check_range(i);
		if (selected[i]) {
			list[i][0]='๛';
			mint++; }
		disa[i]=0; }


	wblock (3,17,63,4,44,NULL,0);
	wattr (45);

	j=1;
	cont=false;
	do {
		j=wmenu (3,4,14,48,4,list,disa,44,45,45,46,47,0,
			" ญโฅเขซ๋ ใโฎ็ญฅญจ๏ ",flg,j,-99,"{Enter} - ฅเฅชซ๎็ฅญจฅ   "
			"{F10} - ฌฅญ๎    {F9} - ชฎฃค ฃฎโฎขฎ   {F1} - Cฏเขช",
			display_events);
		flg|=MF_blk;

		if ((j&0xFF80)!=0||j==0)
			switch ((j&0xFF80)>>7) {
			case 0:
			case F10:
				switch(local_menu()) {
				case L_ABANDON:
					if (wverify(25,1,"เฅเขโ์ ฏเฎๆฅcc เฅ่ฅญจ๏",99)>0) {
						wrestore();
						wrestore();
						return (false); }
					break;
				case L_NOACC:
					mint=0;
					for (i=0;i<mpnt-1;i++) {
						selected[i]=false;
						list[i][0]=' '; }
					break;
				case L_ALACC:
					mint=mpnt-1;
					for (i=0;i<mpnt-1;i++) {
						selected[i]=true;
						list[i][0]='๛'; }
					break;
				case L_DFACC:
					mint=0;
					for (i=0;i<mpnt-1;i++) {
						selected[i]=check_range(i);
						if (selected[i]) {
							list[i][0]='๛';
							mint++; }
						else
							list[i][0]=' '; }
					break;
				case L_CONT:
					cont=true;
				case L_GOBAK:
					break; }
				break;
			case F9:
				cont=true;
				break; }
		else {
			selected[j-1]=!selected[j-1];
			list[j-1][0]=selected[j-1]?'๛':' ';
			mint+=selected[j-1]?1:-1; }
		j&=0x007F; }
   while (!cont);

	wrestore();
	wrestore();
	return (true);
}


static void build_index()

{
	int i,j,k,m0;

	m0=mpnt+mpex*mint;
	Alloc (Tx,m0);
	Alloc (Px,m0);
	Alloc (ixJ,m0);

	M0=0; k=mpnt;

	for (i=0;i<mpnt;i++) {
		Tx[M0]=get_tp_1 (ctask.t0,ctask.t1,i);
		Px[M0]=get_tp_1 (ctask.p0,ctask.p1,i);
		ixJ[M0++]=i;
		if (i<mpnt-1&&selected[i])
			for (j=0;j<mpex;j++,k++) {
				Tx[M0]=get_tp_2 (ctask.t0,ctask.t1,i,j);
				Px[M0]=get_tp_2 (ctask.p0,ctask.p1,i,j);
				ixJ[M0++]=k; } }

	Alloc (ixN,I0);
	N0=0;
	for (i=0;i<I0;i++) {
		for (j=0;j<m0;j++)
			if (C[i].c2[j].g>0)
				break;
		if (j!=m0)
			ixN[N0++]=i; }

}



#pragma warn -pia

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Phase  1.  Build  mattrix,  them  perform  reviewal solving the บ
ณ system.                                                         บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool phase_1 (void)

{
	Bool Ok;
	if ((Ok=build_mattrix ()))
		solve_system (REVIEWAL);
	return (Ok);
}

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Phase  2.  Ask  user  for  enaccuratements; if he answered that บ
ณ there're ones expand and fill in enchanced (for  next  solving) บ
ณ columns in Ci mattrix, then perform enaccurating solution.      บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

static Bool phase_2 (void)

{
	Bool Ok;

	if ((Ok=search_enaccuratement())) {
		if (mint!=0) {
			expand_mattrix ();
			fill_in_expanded_columns();
			solve_system (ACCURATE); }
		build_index(); }
	return (Ok);
}

#pragma warn +pia

/*
ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤท
ณ                                                                 บ
ณ Solve  service  called from CHEMICAL main menu. Performs phases บ
ณ 1&2 and then if successful calls  output_results  service  from บ
ณ RESULT module to view, print and graphic output the solution.   บ
ณ                                                                 บ
ิอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
*/

void solve_service ()

{
	Recovery_section
		free_work();
	End_of_recovery_section

	mpnt=0;
	mint=0;
	if (!primary_build()) return;
	if (phase_1() && phase_2())
		output_results ();
	free_work();
	display_core();

/*	{
		#include <conio.h>
		#include <stdio.h>

		int i,j;

		clrscr();
		printf ("\nI0=%d  J0=%d  L0=%d    M: ",I0,J0,L0);
		for (j=0;j<F0;j++) printf ("%d  ",M[j]);
		printf ("\n");
		for (i=0;i<I0;i++) {
			printf ("%3dณ ",i);
			for (j=0;j<J0+L0;j++) printf ("%6.1f",A[i][j]);
			printf (" %12s ณ %c ณ ",C[i].adinf,(C[i].flag&DB_sol)?'C':'v');
			for (j=0;j<mpnt;j++) printf ("%4d",(unsigned)C[i].c2[j].d);
			printf (" ณ\n"); }
	}
	*/
}
